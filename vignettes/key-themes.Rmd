---
title: "key-themes"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{key-themes}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(MicroMoB)
```

Here we are going to talk about some key themes to follow while building this software library.

## Data provenance

It should be clear how external input data gets turned into the parameters used
by Micro-MoB during simulation. Specifically, if we define some tree 
structure of data such that the leaves are mutually exclusive (e.g.; entomology,
vector control, human movement, drug treatment, etc), we know for each
data structure and function what leaves they use.

This is important because it lets us figure out what changes when data changes.

## Model structure

We need to get a list of model state objects, and updating functions. Then we need
to describe how the process executes a time step. This helps us uncover hidden
constraints in the model.

This is also a step closer to being able to construct multiple representations of
the model (e.g. as machines or resource sharers).

## Extensions

It needs to be clear how to link to this package from another package if you want
to extend the methods here. We need to think about what kind of a simulation
engine we are making and how other people will extend it.

One thing we can do here is make the basic state objects (see above topic) and 
define how to queue updates and access them, and a simulation loop that updates
them, then users can write their own processes. Like what we do with individual
but with more enforced constraints.

## Software design

Once we establish what are the data structures that store persistent state in the
model, we need to decide how to enforce some kind of type consistency for them.
This assumes that those data structures will be used by *all* models that can
be built using Micro-MoB.

One way is to use assertions prior to calling `UseMethod` to make sure that the 
required inputs are provided.

```r
BloodFeeding = function(t, Mod){
  UseMethod("BloodFeeding", Mod$bloodfeedingPars)
}
```

This is probably the right way to do things. The outer generic function can just
check that some bare minimum of input exists. The implemented specific function
can do further checking based on its internal state representation.

Another way would be more complex. We could enforce that users interact with the model
object through an interface which ensures consistency.

An easy performance thing is to make everything a `Matrix` object so that matrix mult
is faster.

## Model object

We should store the model object as an environment. [This gist](https://gist.github.com/slwu89/a294203e6d6679b923276030516684d7)
shows why. Luckily conversion to-from is as easy as `list2env` and `as.list`.

## Analysis

One thing that would be nice is for each model, no matter how complex, we'd like
to compute quantities that are "standard parameters", such as feeding rate, human
blood index, etc. The fundamental RM parameters should be computable from model
parameters without simulation.

## Simulation update

### Simulation loop

Here it is:

```r
MicroSimulation = function(Model){with(Model$runtime,{
  # Defined in Micro-MoB
  for(t in T0:Tmax){
    if (t %% 100 == 0) print(paste("t =", t)) 
    Model = dMicroSim(t, Model)
    Model = IO(t, Model)
    Model = Update(t, Model)
  } 
  return(Model)
})}
```

### Update

There's a couple of ways to do a discrete time simulation, regardless of if
it is seen as a discretization of an underlying continuous time process or the
model is developed "from scratch" as a discrete time model (this amounts to
asking if a rate or a probability is the fundamental quantity specified by a modeler).

Anyway for discrete time, we basically can either do:

  1. Synchronous update - this is like how cellular automata work (usually), all
  units which may undergo a state change draw their state changes simultaneously
  based on the same (yet unchanged) state. All updates are then applied instantaneously.
  This is what individual does, even though it doesn't initially appear to be the
  case, because updated are merely queued by processes, they aren't applied until
  the time step ends.
  2. Asynchronous update - this is what Micro-MoB does. State is updated by processes
  which are executed during each time step. This requires more caution, although
  it can result in processes functions which are shorter and more specialized.
  Basically, state that is used to compute probabilities or proportions _cannot_
  be modified until it is no longer being used to compute those dynamic values.

The former means you need to spend more time working on the model's engine ... its
software architecture. That's why individual has such a large amount of code dedicated
to queuing and executing state updates. So you spend some upfront cost, but you
get to have more leeway with your model processes.

The latter is easier to get running with right away and is a bit more freewheeling.
But you need to be very careful about the execution order of processes. The upshot
is that it may be easier to compartmentalize functions that work on smaller parts
of state.

The terms synchronous and asynchronous are wrong, because these mean quite different
things [when used rigorously](https://en.wikipedia.org/wiki/Asynchronous_cellular_automaton).
We're just talking about queuing updates that execute all at once versus
executing updates sequentially in such a way that it mimics queuing those updates.

The update loop is fundamental. Let's see what it says:

```r
dMicroSim = function(t, Mod){
  # Defined in Micro-MoB
  ##########################################
  # + IRS Spraying
  # + ITN Mass Distribution
  # ... and other modes of vector control
  # + Mass Treatment
  # + Reactive Case Detection
  # ... and other health-based interventions
  ##########################################
  Mod = Intervene(t, Mod)
  
  ##########################################
  #  Called by: 
  #    + some models of aquatic mosquito
  #      populations with dynamic resources 
  #      & resource-based competition. 
  #########################################
  #Mod = Update(t, Mod)  

  ###########################
  # Micro-Human.Rmd 
  # + TimeSpent
  # + MyITN, UseITN
  ###########################
  Mod = HumanBehavior(t, Mod)

  ###########################
  # VectorControl.Rmd 
  # + ITNs, IRS, LSM
  ###########################
  Mod = VectorControlEffects(t, Mod)

  #######################
  # Micro-BloodFeeding.Rmd
  # + FeedingSuccess modifies MPars$psi
  # + kappa, eir, Q
  #######################
  Mod = BloodFeeding(t, Mod)
  
  ##############################
  # Micro-Mosquito.Rmd
  # Micro-Mosquito-Adult.Rmd
  # Micro-Mosquito-Aquatic.Rmd
  # + dMdt
  # + dLdt
  ##############################
  Mod = MosquitoDynamics(t, Mod) 

  ###############################
  # HumanMicro.Rmd
  # + P.falciparum
  ###############################
  Mod = InfectionDynamics(t, Mod)
  
  return(Mod) 
}
```

So here's the order in which things happen:

  1. `Intervene` - this instantaneously changes model state before anything happens. In this
  sense it happens "between" the ticks of the clock, so that all updates see the newly intervened-upon
  state when they execute their updates on this day.
  2. `Update` - currently unused. I guess it updates the aquatic populations? That should be ok,
  as long as adults are not modified until `MosquitoDynamics`.
  3. `HumanBehavior` - 
  
Okay, so we need to specify what parts of state are "out of bounds" for updating prior 
to a certain point in the loop. What we mean is that it's easier to shoot yourself in the
foot this way, for example if someone (for some reason ...) made a `Update` function
that killed adult mosquitoes, that would break the contract that process has 
with other updating processes, because downstream processes need the unmodified adult
mosquito state to calculate probabilities. If we did this, we'd be updating adult mosquitoes
more than once, which isn't okay.

Another way to see this is by thinking of a SIR model with birth and death. In discrete
time it might look like this.

\begin{equation}
\begin{array}{rl}
S(t+1) &= S(t) + b N(t) - \beta S(t) I(t) - \mu S(t) \\
I(t+1) &= I(t) + \beta S(t) I(t) - \gamma I(t) - \mu I(t) \\
R(t+1) &= R(t) + \gamma I(t) - \mu R(t)
\end{array}
\end{equation}

Now let's say we do things wrong. Let's execute a demographics function and update
state before infection.

\begin{equation}
\begin{array}{rl}
S^{\prime}(t) &= S(t) + b N(t) - \mu S(t) \\
I^{\prime}(t) &= I(t) - \mu I(t) \\
R^{\prime}(t) &= R(t) - \mu R(t)
\end{array}
\end{equation}

Ok, now let's apply the infection function.

\begin{equation}
\begin{array}{rl}
S^{\prime}(t+1) &= S^{\prime}(t) - \beta S^{\prime}(t)I^{\prime}(t) \\
I^{\prime}(t+1) &= I^{\prime}(t) + \beta S^{\prime}(t)I^{\prime}(t) - \gamma I^{\prime}(t) \\
R^{\prime}(t+1) &= R^{\prime}(t)  + \gamma I^{\prime}(t)
\end{array}
\end{equation}

Which aren't equivalent.


```{r}
b <- 0.01
beta <- 0.0025
mu <- 1/70
gamma <- 1/7
SIR <- c(500, 50, 10)

synchronous_sir <- function(sir) {
  s <- sir[1]; i <- sir[2]; r <- sir[3]
  n <- s + i + r
  c(
    s + (b*n) - (beta*s*i) - (mu*s),
    i + (beta*s*i) - (gamma*i) - (mu*i),
    r + (gamma*i) - (mu*r)
  )
}

asynchronous_sir_demographics <- function(sir) {
  s <- sir[1]; i <- sir[2]; r <- sir[3]
  n <- s + i + r
  c(
    s + (b*n) - (mu*s),
    i - (mu*i),
    r - (mu*r)
  )
}

asynchronous_sir_infection <- function(sir) {
  s <- sir[1]; i <- sir[2]; r <- sir[3]
  n <- s + i + r
  c(
    s - (beta*s*i),
    i + (beta*s*i) - (gamma*i),
    r + (gamma*i)
  )
}

sync_sir <- synchronous_sir(SIR)

sync_sir_d <- asynchronous_sir_demographics(SIR)
sync_sir_i <- asynchronous_sir_infection(sync_sir_d)

dt <- data.frame(rbind(sync_sir, sync_sir_i),row.names = c("Synchronous", "Asynchronous"))
colnames(dt) <- c("S", "I", "R")
dt
```
## Data structures & processes

Data structures are how the model stores state. Not all parts of state are the minimum state (the state required to specify the model and sample/compute the next update). Let's call anything thats part of the minimum model state to be _persistent state_ and anything else _transient state_ (e.g., predictable functions of the history of the process).

The best way to go about this by looking at all the update functions which are executed each time step and see what they input and what they output (or, what they compute or update).

What we want to do is this (I think). For each of these update/component functions we want to dispatch on an object
class that contains everything that function will update ("output") and also contains all relevant parameters (`Update` might
be an exception). We want to make clear what other model objects it uses to compute those ("input").

### Intervene

This is described in `Micro-Intervene.Rmd`. It looks like this and is currently not implemented.

```r
Intervene = function(t, Mod){
  # Defined in Micro-Intervene.Rmd
  if(length(Mod$intervene)>0){
    for(i in 1:length(Mod$intervene)){
      Mod = intervene(i,t,Mod)
    }
  }
  return(Mod)
}
```

#### Input

  * `Mod$intervene`: a list of interventions I suppose. I guess `intervene` then dispatches based on the class of each intervention in the list.
  
#### Output

None yet.

### Update

This is described in `Micro-ModelObject.Rmd`. It looks like this and is currently not implemented.

```r
Update = function(t, Mod){
  # Defined in Micro-ModelObject.Rmd
  if(length(Mod$update)>0){
    for(i in 1:length(Mod$update)){
      Mod = update(i,t,Mod) 
    } 
  }
  return(Mod)
}
```

An update is a generic function in a list that can change parameters or other features of a model.

+ `update$F` is a function of the form `F(t, Mod, pars)` 

+ `update$pars` holds the parameters passed to the function `F` 

The `update` object is an arbitrarily long list of updates. 

#### Input

  * `Mod$update`: a list of updates I suppose. I guess `update` then dispatches based on the class of each intervention in the list.
  
#### Output

None yet.

### HumanBehavior

This is described in `Micro-Human.Rmd`.

```r
HumanBehavior = function(t, mod){
  mod = SpendTime(t, mod)
  mod = Travel(t, mod) 
  mod = Fever(t, mod)
  mod = CareSeeking(t, mod)
  mod = OwnITN(t, mod)
  mod = UseITN(t, mod)
  return(mod)
}
```

We have to break down things in terms of each component function.

#### SpendTime

Dispatches on this class:

```r
SpendTime = function(t, mod){
  UseMethod("SpendTime", mod$host$spendtimePars)
}
```

##### Input

Things in that class?

##### Output

  * `Mod$TimeSpent`: modifies the time spent matrix

#### Travel

Dispatches on this class:

```r
Travel = function(t, mod){
  UseMethod("Travel", mod$host$travelPars)
}
```

##### Input

Things in that class?

##### Output

  * `Mod$TravelAR`: modifies this object
  
#### Fever

Dispatches on this class:

```r
Fever = function(t, mod){
  UseMethod("Fever", mod$host$feverPars)
}
```

##### Input

Things in that class?

##### Output

Things in `mod$host$feverPars`?

#### CareSeeking

Dispatches on this class:

```r
CareSeeking = function(t, mod){
  UseMethod("CareSeeking", mod$host$careseekingPars)
}
```

##### Input

Things in that class?

##### Output

Things in `Mod$host$careseekingPars`?

#### OwnITN

In `Micro-VectorControl-ITN.Rmd`

```r
OwnITN = function(t, mod){
  UseMethod("OwnITN", mod$vectorcontrol$itnPars)
}
```

##### Input

##### Output

#### UseITN

In `Micro-VectorControl-ITN.Rmd`

```r
UseITN = function(t, mod){
  UseMethod("UseITN", mod$vectorcontrol$itnPars)
}
```

##### Input

##### Output

### VectorControlEffects

This is described in `Micro-VectorControl.Rmd`.

```r
VectorControlEffects = function(t, Mod){
  Mod = resetBaseline(Mod) 
  Mod = ITNEffects(t, Mod)
  Mod = IRSEffects(t, Mod)
  Mod = LSMEffects(t, Mod)
  #Mod = ATSB(t, Mod)
  return(Mod)
}
```

Again, we have to break things down and look at each component function.

#### resetBaseline

This just resets mosquito parameters to baseline prior to computing the effect
from today's vector control.

Found in `Micro-VectorControl.Rmd`

```r
resetBaseline = function(Mod){
  # Defined in Micro-VectorControl.Rmd
  for(i in 1:Mod$nMosquito){
    Mod$mosquito[[i]]$adultPars = Mod$mosquito[[i]]$adultBase
    Mod$mosquito[[i]]$aquaPars = Mod$mosquito[[i]]$aquaBase
  }
  return(Mod)
}
```

#### ITNEffects

In `Micro-VectorControl-ITM.Rmd`. Note the multiple dispatch.

```r
ITNEffects = function(t, mod){
  UseMethod("ITNEffects", mod$vectorcontrol$itnPars)
}
```

#### IRSEffects

In `Micro-VectorControl-IRS.Rmd`. There's no dispatch function yet, but there should
be. There seems to be one class method, for class `step`:

```r
IRSEffects.step = function(t, Mod, i=1){ 
  #############################################
  # efficacy is modeled as a step function 
  # daily survival at the haunts is reduced by 1-IRScoverage
  # for a number of days specified by 'duration'  
  #############################################
  fac = rep(1, Mod$landscape$nHaunts)
  ix = which(t-Mod$landscape$haunts$daySprayed) < Mod$vectorcontrol$irsPars$duration 
  fac[ix] = 1-Mod$landscape$haunts$IRScoverage[ix]
  Mod = adjust(fac, Mod)
}
```

#### LSMEffects

LSM means Larval Source Management. This is in `Micro-VectorControl.Rmd`.

```r
LSMEffects = function(t, Mod){
   UseMethod("LSMEffects", Mod$vectorcontrol$lsmPars)
}
```

#### ATSB

Not implemented yet.

### BloodFeeding

This is a supremely important function. After this function executes, we are free
to update the state of adult mosquitoes and human infections. It's all stored in
`Micro-BloodFeeding.Rmd`.

The basic dispatch is here:

```r
BloodFeeding = function(t, Mod){
  UseMethod("BloodFeeding", Mod$bloodfeedingPars)
}
```
