---
title: "math"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{math}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(MicroMoB)
```

### Net infectiousness of humans $\kappa$

In a standard Ross-Macdonald model, the force of infection on mosquitoes is $acX$
where $X = I/H$ is prevalence of disease in humans, $a = fq$ is the human
feeding rate, and $c$ is the transmission efficiency. From this, we know $\kappa$
is the part referring to the net infectiousness of the human host population, 
the proportion of bites on humans which infect a mosquito.

```{r}
H <- 100
I <- 20
c <- 0.15
X <- I/H

kappa <- c * X
kappa
```

In Micro-MoB and RM-Spatial it's calculated like this:

$$
\kappa_{p\times 1} = \upsilon_{p\times 1} (\beta_{p\times n}^{\intercal} x_{n\times1}) + (1 - \upsilon_{p\times 1})x_{\delta_{p\times 1}}
$$
Here, $\upsilon_{p\times 1}$ is the resident fraction in each patch, $x_{\delta_{p\times 1}}$ is the net infectiousness of visitors, and
$\beta_{n\times p}$ is the biting distribution matrix.

In order to try to sync the models, lets examine how $\beta$ is made:

$$
\beta_{n\times p} = \mbox{diag}(w_{f})_{n\times n} \cdot \Psi_{n\times p} \cdot \mbox{diag}(1/W)_{p\times p}
$$

Where $W_{p\times 1} = \Psi^{\intercal}_{p\times n} \cdot w_{f}H_{n\times 1}$ is the available human population, $\Psi = \Theta \xi$ is the time at risk matrix,
and $w_{f}$ are biting weights.

To line up with the simple $\kappa$ from the RM model, let's assume there is only 1 patch, 1 strata, and the biting weight is $1$. We assume that
there are no visitors, such that $\upsilon = 1$.

```{r}
Theta <- matrix(1, nrow = 1, ncol = 1)
Psi <- Theta * 1
w_f <- 1
W <- t(Psi) %*% (w_f * H)

beta <- diag(w_f) %*% Psi %*% diag(1/W)

x <- c * X

kappa_new <- t(beta) %*% (x)
kappa_new
```

It looks like new $\kappa$ is off, in fact its off by precisely a factor of $1/H$, as I suspected:

```{r}
kappa_new * H
```

This is because $\beta$ simplifies to $1/H$. So the new computation of $\kappa$ has 
an extra term of $1/H$ that is extraneous:

$$
\beta = 1 \cdot (1) \cdot (1/H) \\
\kappa = (1/H) cx = (1/H)c(I/H)
$$

Fix by doing:

$$
\beta^{\intercal} (xH)
$$

## Human availability

This returns something akin to the expectation number of persons available to be
bitten at place $i$ and time $t$. It's an expectation because we weight the population
by $w_f$ (so still in units of people) and then multiply by a matrix of probabilities.

\begin{equation}
W(t) = \Psi(t)^T \cdot w_f H
\end{equation}

I contend that it is more intuitive to write it this way:

\begin{equation}
W(t) = (\Theta(t)^T \cdot w_f H) \xi(t)
\end{equation}

It gives the same answer either way. The second way we clearly see that what is going
on is $(\Theta(t)^T \cdot w_f H)$ is the expected number of people at each patch,
and then we multiply by the probability of the mosquito to take a bite at that time.

It's a little confusing when that's hidden by $\Psi$.

An example with 2 patches and 3 strata (so vector $H$ is length 6).

```{r}
H <- c(s1p1 = 50, s1p2 = 20, s2p1 = 10, s2p2 = 30, s3p1 = 20, s3p2 = 10)
wt <- rep(1, length(H))
wt <- setNames(wt, names(H))

theta_day <- matrix(
  c(0.4, 0.6,
    0.5, 0.5,
    0.2, 0.8,
    0.5, 0.5,
    0.6, 0.4,
    0.2, 0.8), nrow = length(H), ncol = 2, byrow = TRUE
)

# same thing
t(theta_day) %*% (wt * H)
c(sum(H * theta_day[, 1]), sum(H * theta_day[, 2]))

theta_night <- matrix(
  c(0.9, 0.1,
    0.6, 0.4,
    0.5, 0.5,
    0.6, 0.4,
    0.8, 0.2,
    0.4, 0.6), nrow = length(H), ncol = 2, byrow = TRUE
)

# xi_day <- 0.3
# xi_night <- 0.7

xi_day <- 0.15
xi_night <- 0.85

((t(theta_day) %*% (wt * H)) * (xi_day)) + ((t(theta_night) %*% (wt * H)) * (xi_night))

# (((t(theta_day) * xi_day) %*% (wt * H))) + (((t(theta_night) * xi_night) %*% (wt * H)))
```

## Time spent and time at risk

Let's think about this in terms of person-time.



```{r}
n <- 3 # strata
p <- 4 # places

wf <- c(0.5, 1, 2)
H <- c(200, 120, 75)

Theta <- matrix(rexp(n*p), nrow = n, ncol = p)
Theta <- Theta / rowSums(Theta)

W <- t(Theta) %*% (wf * H)



d <- 4

Theta_d <- lapply(X = 1:d, FUN = function(x) {
  Theta <- matrix(rexp(n*p), nrow = n, ncol = p)
  Theta <- Theta / rowSums(Theta)
  return(Theta)
})
xi <- rexp(d)
xi <- xi / sum(xi)

W_d <- lapply(X = 1:d, FUN = function(t) {
  t(Theta_d[[t]] * xi[t]) %*% (wf * H)
})

Reduce("+", W_d)

```



